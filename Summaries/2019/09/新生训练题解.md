## Zmei Gorynich
* 题意：勇者斗恶龙，龙有X滴血，勇者有n个技能，每个技能可以用无限次。第i个技能使用后会对龙造成$h_i$点伤害，如果这时龙没有死，龙会增加$d_i$血，问最少使用多少次技能可以杀死龙，如果杀不死，就输出-1.
* 解法： 首先找出攻击力最大的技能，再找出$h_i-d_i$最大的技能。
  * 如果攻击力最大的技能可以直接杀死龙，次数为1
  * 用$h_i-d_i$最大的技能攻击龙，一直攻击到使用攻击力最大的技能可以杀死龙为止。计算次数。
  * 如果$h_i-d_i$均小于等于0，显然杀不死龙。
```cpp
#include <iostream>
using namespace std;
const int maxn = 3E5 + 5;
int main()
{
    int T; cin >> T;
    while( T -- )
    {
        int n, x;
        cin >> n >> x;
        int maxAttack = 0, maxDecrease = 0;
        while( n -- )
        {
            int attack, increase;cin >> attack >> increase;
            maxAttack = max( maxAttack, attack ); maxDecrease = max( maxDecrease, attack - increase );
        }
        if( maxAttack >= x ) cout << 1 << endl;
        else if ( maxDecrease == 0 ) cout << - 1 << endl;
        else cout << ( x - maxAttack + maxDecrease - 1 ) / maxDecrease + 1 << endl;
    }
}
```
## Wrong Subtraction
* 按照题意模拟即可
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n, k; cin >> n >> k;
    for( int i = 0; i < k; ++ i )
        if( n % 10 ) n --;
        else n /= 10;
    cout << n << endl;
}
```
## Beautiful Matrix
* 按照题意模拟即可
```cpp
#include <iostream>
using namespace std;
int main()
{
    int x, y;
    for (int i = 0; i < 5; ++ i)
        for (int j = 0; j < 5; ++ j)
        {
            int t; cin >> t;
            if (t) { x = i; y = j; }
        }
    cout << abs(x - 2) + abs(y - 2) << endl;
}
```
## Game 23
* 题意：给定n，m。m要么除以3要么除以2，问最少多少步可以到达n，如果不能到达，输出-1
* 解法：
  * 首先判断可不可行，即n是不是m的因子。
  * 然后用m/n，对于结果能除3尽量除3，能除2尽量除2
```cpp
#include<iostream>
using namespace std;
int main()
{
    int n, m; cin >> n >> m;
    if( m % n )
    {
        cout << -1 << endl;
        return 0;
    }
    int time = m / n;
    int ans = 0;
    while( !( time % 2 ) ) { ans ++; time /= 2; }
    while( !( time % 3 ) ) { ans ++; time /= 3; }
    if( time == 1 ) cout << ans << endl;
    else cout << -1 << endl;
}
```
## Square Filling
* 题意: 给定两个矩阵A，B。每次可以在B中选择2x2的子矩阵把其中元素变成1,问经过几步可以把空矩阵B变成A，并输出方案，如果不能，输出-1；
* 解法：如果发现A中以某个元素为左上角的2x2的矩形都是1，那么B也要相应的填上。最后判断一下A和B是不是一样即可。
```cpp
#include <iostream>
using namespace std;
const int maxn = 55;
int A[maxn][maxn], B[maxn][maxn], ansX[maxn*maxn], ansY[maxn*maxn], tot = 0;
int main( )
{
    int n, m; cin >> n >> m;
    for( int i = 1; i <= n; ++ i )
        for( int j = 1; j <= m; ++ j )
            cin >> A[i][j];
    for( int i = 1; i < n; ++ i )
        for( int j = 1; j < m; ++ j )
            if( A[i][j] == 1 && A[i + 1][j] == 1 && A[i][j + 1] == 1 && A[i + 1][j + 1] )
            {
                ansX[tot] = i; ansY[tot++] = j;
                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1;
            }
    for( int i = 1; i <= n; ++ i )
        for( int j = 1; j <= m; ++ j )
            if( A[i][j] != B[i][j] )
            {
                cout << -1 << endl;
                return 0;
            }
    cout << tot << endl;
    for( int i = 0; i < tot; ++ i ) cout << ansX[i] << " " << ansY[i] << endl;
}
```
## Theatre Square
* 题意：给定n*m的矩形最少用多少个a * a的矩形可以完全覆盖，允许拼成的矩形大于n * m；
* 解法：想上取整即可。
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
    long long n, m , a;
    long long num;
    cin >> n >> m >> a;
    num = ceil( (double)n / a) * ceil ((double)m / a);
    cout << num << endl;
}
```
## k-rounding
* 题意：找到n的最小的一个倍数，以大于等于k个0结尾。
* 解法：要凑成0，首先n的因子里要有2和5，因为要最小，所以先利用5，再利用2，如果不够再利用10。
```cpp
#include <iostream>
using namespace std;
int main()
{
    long long n; int k;
    while( cin >> n >> k )
    {
        unsigned long long t = n;
        while( t % 10 == 0 ) { k --; t /= 10; }
        while( k > 0 && t % 5 == 0) { t /= 5; n *= 2; k --; }
        while( k > 0 && t % 2 == 0 ) { t /= 2; n *= 5; k --; }
        while( k > 0 ) { n *= 10; k --; };
        cout << n << endl;
    }
}
```
## Jzzhu and Sequences
* 题意清晰明了
* 解法:
  * 矩阵快速幂
  * 当如果多写几项会发现其实有规律。。
### 规律
```cpp
#include <stdio.h> 
 
#define MD 1000000007
 
int main() {
	long long x, y, n, ans; scanf("%lld%lld%lld", &x, &y, &n);
	if (n % 6 == 1) ans = (x + MD) % MD;
	else if (n % 6 == 2) ans = (y + MD) % MD;
	else if (n % 6 == 3) ans = ((y + MD) % MD) - ((x + MD) % MD);
	else if (n % 6 == 4) ans = (-x + MD) % MD;
	else if (n % 6 == 5) ans = (-y + MD) % MD;
	else ans = -(((y + MD) % MD) - ((x + MD) % MD));
	printf("%lld\n", (ans + MD) % MD);
	return 0;
}
```
### 矩阵
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
 
using namespace std;
 
const int maxn = 10;
const int mod = 1e9 + 7;
 
struct Matrix
{
    long long num[maxn][maxn];
    Matrix()
    {
        memset( num, 0, sizeof(num) );
    }
    Matrix( int n )
    {
        for( int i = 1; i <= n; ++ i)
        {
            for( int j = 1; j <= n; ++ j )
            {
                if( i == j )
                    num[i][j] = 1;
                else
                    num[i][j] = 0;
            }
        }
    }
    print( int n )
    {
        for( int i = 1; i <= n; ++ i )
        {
            for( int j = 1; j <= n; ++ j )
            {
                cout << num[i][j] << " ";
            }
            cout << endl;
        }
    }
};
 
Matrix multi( Matrix &A, Matrix &B, int n )
{
    Matrix ans;
    for( int i = 1; i <= n; ++ i )
    {
        for( int j = 1; j <= n; ++ j )
        {
            for( int k = 1; k <= n; ++ k )
            {
                ans.num[i][j] += ( ( A.num[i][k] % mod ) * ( B.num[k][j] % mod ) + mod ) % mod;
            }
        }
    }
    return ans;
}
 
Matrix M_Quickpow( Matrix a, int k, int n )
{
    Matrix ans = Matrix(n);
    Matrix res = a;
    while( k )
    {
        if( k & 1 )
        {
            ans = multi( ans, res, n );
        }
        res = multi( res, res, n );
        k >>= 1;
    }
    return ans;
}
 
int main()
{
    long long x, y, n;
    cin >> x >> y >> n;
    Matrix a;
    a.num[1][1] = 1, a.num[1][2] = -1, a.num[2][1] = 1, a.num[2][2] = 0;
    if( n > 2 )
    {
        a = M_Quickpow( a, n - 2, 2 );
        cout << ( ( a.num[1][1] * y + mod ) % mod + ( a.num[1][2] * x + mod ) % mod + mod ) % mod << endl;
    }
    else if( n == 1 )
    {
        cout << ( x + mod ) % mod << endl;
    }
    else
        cout << ( y + mod ) % mod << endl;
}
```
## 	Polycarp Restores Permutation
* 题意：给定一个排列的差分，要求重构这个数组。
* 解法：假定开头的元素是0，先重构一边，找到最小值，然后想办法把这个序列变成从一开始的排列即可。
```cpp
#include<iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
const long long maxn = 4E5 + 5;
long long a[maxn];
bool ok[maxn];
int main()
{
    long long n; cin >> n;
    long long Min = 1000000;
    a[0] = 0;
    memset( ok, 0, sizeof(ok) );
    for( long long i = 1; i < n; ++ i )
    {
        long long t; cin >> t;
        if( i == 1 ) a[i] = t;
        else a[i] = t + a[i - 1];
        Min = min( Min, a[i] );
    }
    long long first;
    if( Min < 0 ) first = - Min + 1;
    else first = 1;
    bool flag = 1;
    for( long long i = 0; i < n; ++ i )
    {
        a[i] += first;
        if( a[i] > n ) { flag = 0; break; }
        ok[a[i]] = 1;
    }
    if( flag )
        for( long long i = 1; i <= n; ++ i )
            if( !ok[i] ) { flag = 0; break; }
    if( flag )
    {
        for( long long i = 0; i < n; ++ i )
            cout << a[i] << " ";
        cout << endl;
    }
    else cout << -1 << endl;
}
```